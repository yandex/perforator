package main

import (
	"fmt"
	"io"
	"sort"
	"strings"
	"text/template"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/btf"
	"golang.org/x/exp/constraints"
	"golang.org/x/exp/maps"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// Info of the converted golang version of the type
type typeInfo struct {
	// C type name.
	SystemName string

	// Golang type name.
	Name string

	// Human-readable kind (struct, enum, etc).
	// Use for debugging purposes.
	Kind string

	// Snippet of the golang code to define the type.
	Definition string
}

type funcInfo struct {
	Definition string
}

type importInfo struct {
	Name string
}

type GoFormatter struct {
	w        io.Writer
	spec     *btf.Spec
	builtins map[string]string
	public   map[string]btf.Type
	prefix   string
	pkg      string

	// Mapping of all known types.
	// Types that have to be defined explicitly have non-empty @definition field.
	types map[btf.Type]*typeInfo

	// User-facing public maps.
	maps  map[*ebpf.MapSpec]bool
	progs map[*ebpf.ProgramSpec]bool
}

func NewFormatter(w io.Writer, spec *btf.Spec) *GoFormatter {
	builtins := map[string]string{
		"u8":  "uint8",
		"u16": "uint16",
		"u32": "uint32",
		"u64": "uint64",

		"s8":  "int8",
		"s16": "int16",
		"s32": "int32",
		"s64": "int64",

		"i8":  "int8",
		"i16": "int16",
		"i32": "int32",
		"i64": "int64",

		"__u8":  "uint8",
		"__u16": "uint16",
		"__u32": "uint32",
		"__u64": "uint64",

		"__s8":  "int8",
		"__s16": "int16",
		"__s32": "int32",
		"__s64": "int64",

		"bool": "bool",
		"char": "byte",
	}
	return &GoFormatter{
		w:        w,
		spec:     spec,
		builtins: builtins,
		public:   make(map[string]btf.Type),
		types:    make(map[btf.Type]*typeInfo),
		maps:     make(map[*ebpf.MapSpec]bool),
		progs:    make(map[*ebpf.ProgramSpec]bool),
	}
}

func (f *GoFormatter) AddPublicType(t btf.Type) *GoFormatter {
	f.public[t.TypeName()] = t
	return f
}

func (f *GoFormatter) AddPublicMap(m *ebpf.MapSpec) *GoFormatter {
	f.addTopLevelMap(m)
	f.addPublicMap(m)
	return f
}

func (f *GoFormatter) AddProgram(p *ebpf.ProgramSpec) *GoFormatter {
	f.progs[p] = true
	return f
}

func (f *GoFormatter) addTopLevelMap(m *ebpf.MapSpec) {
	f.maps[m] = true
}

func (f *GoFormatter) addPublicMap(m *ebpf.MapSpec) {
	if m.Key != nil {
		f.AddPublicType(m.Key)
	}
	if m.Value != nil {
		f.AddPublicType(m.Value)
	}
	if m.InnerMap != nil {
		f.addPublicMap(m.InnerMap)
	}
}

func (f *GoFormatter) SetPrefix(prefix string) *GoFormatter {
	f.prefix = prefix
	return f
}

func (f *GoFormatter) SetPackage(pkg string) {
	f.pkg = pkg
}

func (f *GoFormatter) Print() error {
	if err := f.collectTypes(); err != nil {
		return err
	}

	if err := f.print(); err != nil {
		return err
	}

	return nil
}

func (f *GoFormatter) collectTypes() error {
	for _, typ := range f.public {
		if err := f.collectChildren(typ); err != nil {
			return err
		}
	}
	return nil
}

func SortBy[T any, F constraints.Ordered](slice []T, field func(T) F) []T {
	sort.Slice(slice, func(i, j int) bool {
		return field(slice[i]) < field(slice[j])
	})
	return slice
}

func addImportsForParsers() []importInfo {
	return []importInfo{{Name: "\"errors\""}}
}

func (f *GoFormatter) print() error {
	programs := SortBy(maps.Keys(f.progs), func(s *ebpf.ProgramSpec) string {
		return s.Name
	})
	maps := SortBy(maps.Keys(f.maps), func(s *ebpf.MapSpec) string {
		return s.Name
	})

	types := make([]*typeInfo, 0)
	for _, typ := range f.types {
		if typ.Definition != "" {
			types = append(types, typ)
		}
	}
	sort.Slice(types, func(i, j int) bool {
		return types[i].Name < types[j].Name
	})

	funcs := genPrimitiveParseFunc()

	imports := []importInfo{{Name: "\"github.com/cilium/ebpf\""}, {Name: "\"unsafe\""}}
	var cntStructs int
	for _, genType := range types {
		if genType.Kind == "struct" {
			cntStructs++
		}
	}
	if cntStructs > 0 {
		imports = append(imports, addImportsForParsers()...)
	}

	t := template.Must(template.New("loader").Funcs(map[string]any{
		"snakeToPascal": snakeToPascal,
		"makeFieldTag": func(name string) string {
			return fmt.Sprintf("`ebpf:\"%s\"`", name)
		},
	}).Parse(`// Code generated by btf2go. DO NOT EDIT.

package {{.Package}}

import (
	{{ range .Imports }}
	{{ .Name }}
	{{ end }}
)

//// Types
{{ range .Types }}
// {{ .Kind }} {{ .SystemName }}
{{ .Definition }}
{{ end }}

//// Funcs
{{ range .Funcs }}
{{ .Definition }}
{{ end }}

//// Programs
{{- $progs := printf "%sProgs" .Prefix }}
type {{$progs}} struct {
{{- range .Programs }}
	{{.Name | snakeToPascal}} *ebpf.Program {{.Name | makeFieldTag}}
{{- end }}
}

func (s *{{$progs}}) Close() error {
{{- range .Programs }}
	if err := s.{{.Name | snakeToPascal}}.Close(); err != nil {
		return err
	}
{{- end }}
	return nil
}

func (s *{{$progs}}) ForEachProg(cb func(*ebpf.Program) error) error {
{{- range .Programs }}
	if err := cb(s.{{.Name | snakeToPascal}}); err != nil {
		return err
	}
{{- end }}
	return nil
}

//// Maps
{{- $maps := printf "%sMaps" .Prefix }}
type {{$maps}} struct {
{{- range .Maps }}
	{{.Name | snakeToPascal}} *ebpf.Map {{.Name | makeFieldTag}}
{{- end }}
}

func (s *{{$maps}}) Close() error {
{{- range .Maps }}
	if err := s.{{.Name | snakeToPascal}}.Close(); err != nil {
		return err
	}
{{- end }}
	return nil
}

func (s *{{$maps}}) ForEachMap(cb func(*ebpf.Map) error) error {
{{- range .Maps }}
	if err := cb(s.{{.Name | snakeToPascal}}); err != nil {
		return err
	}
{{- end }}
	return nil
}

func (s *{{$maps}}) ForEachNamedMap(cb func(string, *ebpf.Map) error) error {
{{- range .Maps }}
	if err := cb("{{.Name}}", s.{{.Name | snakeToPascal}}); err != nil {
		return err
	}
{{- end }}
	return nil
}

/// Objects
{{- $objs := printf "%sObjs" .Prefix }}
type {{$objs}} struct {
	{{$progs}}
	{{$maps}}
}

func (s {{$objs}}) Close() error {
	err := s.{{$progs}}.Close()
	if err != nil {
		return err
	}

	err = s.{{$maps}}.Close()
	if err != nil {
		return err
	}

	return nil
}
`))

	err := t.Execute(f.w, map[string]any{
		"Package":  f.pkg,
		"Prefix":   f.prefix,
		"Maps":     maps,
		"Types":    types,
		"Programs": programs,
		"Funcs":    funcs,
		"Imports":  imports,
	})
	if err != nil {
		return err
	}

	return nil
}

func (f *GoFormatter) collectChildren(typ btf.Type) error {
	_, ok := f.types[typ]
	if ok {
		return nil
	}

	var err error
	var info *typeInfo

	switch v := typ.(type) {
	case *btf.Int:
		info, err = f.visitInt(v)
	case *btf.Pointer:
		info, err = f.visitPointer(v)
	case *btf.Struct:
		info, err = f.visitStruct(v)
	case *btf.Union:
		info, err = f.visitUnion(v)
	case *btf.Enum:
		info, err = f.visitEnum(v)
	case *btf.Array:
		info, err = f.visitArray(v)
	case *btf.Typedef:
		info, err = f.visitTypedef(v)
	default:
		return fmt.Errorf("unsupported type: %+T", typ)
	}
	if err != nil {
		return err
	}

	if builtin, ok := f.builtins[info.Name]; ok {
		info = &typeInfo{Name: builtin}
	}

	f.types[typ] = info

	return nil
}

func (f *GoFormatter) typname(typ btf.Type) string {
	return f.types[typ].Name
}

func genPrimitiveParseFunc() []funcInfo {
	return []funcInfo{
		{Definition: `
func parseInt8(data []byte) int8 {
	return int8(data[0])
}`},
		{Definition: `
func parseUint8(data []byte) uint8 {
	return data[0]
}`},
		{Definition: `
func parseBool(data []byte) bool {
	if data[0] == 0 {
		return false
	}
	return true
}`},

		{Definition: `
func parseByte(data []byte) byte {
	return data[0]
}`},
		{Definition: `
func parseInt16(data []byte) int16 {
	return *(*int16)(unsafe.Pointer(&data[0]))
}`},
		{Definition: `
func parseUint16(data []byte) uint16 {
	return *(*uint16)(unsafe.Pointer(&data[0]))
}`},
		{Definition: `
func parseInt32(data []byte) int32 {
	return *(*int32)(unsafe.Pointer(&data[0]))
}`},
		{Definition: `
func parseUint32(data []byte) uint32 {
	return *(*uint32)(unsafe.Pointer(&data[0]))
}`},
		{Definition: `
func parseInt64(data []byte) int64 {
	return *(*int64)(unsafe.Pointer(&data[0]))
}`},
		{Definition: `
func parseUint64(data []byte) uint64 {
	return *(*uint64)(unsafe.Pointer(&data[0]))
}`},
	}
}

func (f *GoFormatter) getPrimitiveParseFunc(typ *btf.Int) string {
	switch typ.Size {
	case 1:
		if typ.Encoding == btf.Signed {
			return "parseInt8"
		}
		return "parseUint8"
	case 2:
		if typ.Encoding == btf.Signed {
			return "parseInt16"
		}
		return "parseUint16"
	case 4:
		if typ.Encoding == btf.Signed {
			return "parseInt32"
		}
		return "parseUint32"
	case 8:
		if typ.Encoding == btf.Signed {
			return "parseInt64"
		}
		return "parseUint64"
	default:
		return ""
	}
}

func (f *GoFormatter) generateStructParser(w *strings.Builder, v *btf.Struct, name string) error {
	fmt.Fprintf(w, "func parse%s(data []byte) %s {\n", strings.Title(name), name)
	fmt.Fprintf(w, "  var result %s\n", name)
	fmt.Fprintf(w, "  var offset int\n")

	for _, member := range v.Members {
		memberTypeName := f.typname(member.Type)
		memberName := snakeToPascal(member.Name)
		offsetBytes := member.Offset.Bytes()

		fmt.Fprintf(w, "  offset = %d\n", offsetBytes)

		switch typ := member.Type.(type) {
		case *btf.Int:
			parseFunc := f.getPrimitiveParseFunc(typ)
			if parseFunc == "" {
				return fmt.Errorf("unsupported primitive type with size %d and encoding %d", typ.Size, typ.Encoding)
			}
			fmt.Fprintf(w, "  result.%s = %s(data[offset:])\n", memberName, parseFunc)
		case *btf.Struct:
			fmt.Fprintf(w, "  result.%s = parse%s(data[offset:])\n", memberName, strings.Title(memberTypeName))
		case *btf.Array:
			elemTypeName := f.typname(typ.Type)
			elemSize, _ := btf.Sizeof(typ.Type)
			fmt.Fprintf(w, "  for i := 0; i < %d; i++ {\n", typ.Nelems)
			fmt.Fprintf(w, "    result.%s[i] = parse%s(data[offset+i*%d:])\n", memberName, strings.Title(elemTypeName), elemSize)
			fmt.Fprintf(w, "  }\n")
		case *btf.Pointer:
			fmt.Fprintf(w, "  ptr := parseUint64(data[offset:])\n")
			fmt.Fprintf(w, "  result.%s = unsafe.Pointer(uintptr(ptr))\n", memberName)
		case *btf.Enum:
			fmt.Fprintf(w, "  result.%s = parse%s(data[offset:])\n", memberName, strings.Title(memberTypeName))
		case *btf.Typedef:
			fmt.Fprintf(w, "  result.%s = parse%s(data[offset:])\n", memberName, strings.Title(memberTypeName))
		case *btf.Union:
			fmt.Fprintf(w, "  result.%s = parse%s(data[offset:])\n", memberName, strings.Title(memberTypeName))
		default:
			return fmt.Errorf("unsupported type %s for field %s", memberTypeName, memberName)
		}
	}
	fmt.Fprintf(w, "  return result\n")
	fmt.Fprintf(w, "}\n")
	return nil
}

func (f *GoFormatter) generateStructUnmarshal(w *strings.Builder, v *btf.Struct, name string) {
	fmt.Fprintf(w, "func (v *%s) UnmarshalBinary(data []byte) error {\n", name)
	fmt.Fprintf(w, "  if len(data) < %d {\n", v.Size)
	fmt.Fprint(w, "    return errors.New(\"cannot unmarshal from []byte, wrong slice length\")\n  }\n")
	fmt.Fprintf(w, "  *v = parse%s(data)\n", strings.Title(name))
	fmt.Fprint(w, "  return nil\n")
	fmt.Fprint(w, "}\n")
}

func (f *GoFormatter) generateUnionParser(w *strings.Builder, v *btf.Union, name string) {
	fmt.Fprintf(w, "func parse%s(data []byte) %s {\n", strings.Title(name), name)
	fmt.Fprintf(w, "  result := (*[%d]byte)(data)\n", v.Size)
	fmt.Fprintf(w, "  return %s{UnionBuf: *result}\n", name)
	fmt.Fprint(w, "}\n")
}

func (f *GoFormatter) generateEnumParser(w *strings.Builder, v *btf.Enum, name string) {
	fmt.Fprintf(w, "func parse%s(data []byte) %s {\n", strings.Title(name), name)
	fmt.Fprintf(w, "    return %s(parseInt%d(data))\n", name, v.Size*8)
	fmt.Fprint(w, "}\n")
}

func (f *GoFormatter) generateTypedefParser(w *strings.Builder, v *btf.Typedef, name string) {
	fmt.Fprintf(w, "func parse%s(data []byte) %s {\n", strings.Title(name), name)
	fmt.Fprintf(w, "  result := %s(parse%s(data))\n", name, strings.Title(f.typname(v.Type)))
	fmt.Fprint(w, "  return result\n}\n")
}

func (f *GoFormatter) visitInt(v *btf.Int) (*typeInfo, error) {
	if v.Name == "char" {
		return &typeInfo{Name: `byte`}, nil
	}

	prefix := ""
	switch v.Encoding {
	case btf.Bool:
		return &typeInfo{Name: "bool"}, nil
	case btf.Char:
		return &typeInfo{Name: "byte"}, nil
	case btf.Signed:
		break
	case btf.Unsigned:
		prefix = "u"
	}

	return &typeInfo{
		SystemName: v.Name,
		Name:       fmt.Sprintf("%sint%d", prefix, v.Size*8),
	}, nil
}

func (f *GoFormatter) visitPointer(v *btf.Pointer) (*typeInfo, error) {
	if err := f.collectChildren(v.Target); err != nil {
		return nil, err
	}

	return &typeInfo{
		SystemName: fmt.Sprintf(`*%s`, v.Target.TypeName()),
		Name:       fmt.Sprintf(`*%s`, f.typname(v.Target)),
	}, nil
}

func (f *GoFormatter) visitUnion(v *btf.Union) (*typeInfo, error) {
	for _, member := range v.Members {
		err := f.collectChildren(member.Type)
		if err != nil {
			return nil, err
		}
	}

	name := f.goifyTypeName(v)
	w := &strings.Builder{}

	_, _ = fmt.Fprintf(w, "type %s struct {\n", name)
	_, _ = fmt.Fprintf(w, "\tUnionBuf [%d]byte\n", v.Size)
	_, _ = w.WriteString("}\n")

	f.generateUnionParser(w, v, name)

	return &typeInfo{
		SystemName: v.Name,
		Name:       name,
		Kind:       "union",
		Definition: w.String(),
	}, nil
}

func (f *GoFormatter) visitStruct(v *btf.Struct) (*typeInfo, error) {
	for _, member := range v.Members {
		err := f.collectChildren(member.Type)
		if err != nil {
			return nil, err
		}
	}

	name := f.goifyTypeName(v)
	var offset btf.Bits
	var paddingid int
	w := &strings.Builder{}

	emitPadding := func(target btf.Bits, name string) error {
		if offset != target {
			if offset%8 != 0 {
				return fmt.Errorf("field %s.%s has bitfield padding of %d bits", v.Name, name, target-offset)
			}

			padding := (target - offset).Bytes()
			_, _ = fmt.Fprintf(w, "\tPaddingAuto%d [%d]byte\n", paddingid, padding)
			paddingid++
		}
		return nil
	}

	fmt.Fprintf(w, "type %s struct {\n", name)
	for _, member := range v.Members {
		if err := emitPadding(member.Offset, member.Name); err != nil {
			return nil, err
		}

		_, _ = fmt.Fprintf(w, "\t%s %s\n", snakeToPascal(member.Name), f.typname(member.Type))

		// Calculate field size to emit padding
		size, err := btf.Sizeof(member.Type)
		if err != nil {
			return nil, fmt.Errorf("field %s.%s has unsized type %s", v.Name, member.Name, member.Type.TypeName())
		}
		offset = member.Offset + btf.Bits(8*size)
	}

	if err := emitPadding(btf.Bits(v.Size*8), ""); err != nil {
		return nil, err
	}

	w.WriteString("}\n\n")

	if err := f.generateStructParser(w, v, name); err != nil {
		return nil, err
	}
	fmt.Fprint(w, "\n")
	f.generateStructUnmarshal(w, v, name)

	return &typeInfo{
		SystemName: v.Name,
		Name:       name,
		Kind:       "struct",
		Definition: w.String(),
	}, nil
}

func (f *GoFormatter) visitEnum(v *btf.Enum) (*typeInfo, error) {
	name := f.goifyTypeName(v)

	sign := ""
	if !v.Signed {
		sign = "u"
	}

	w := &strings.Builder{}
	fmt.Fprintf(w, "type %s %sint%v\n", name, sign, v.Size*8)
	fmt.Fprintf(w, "const (\n")
	for _, value := range v.Values {
		fmt.Fprintf(w, "\t%s %s = %v\n", f.goifyIdentifier(value.Name), name, value.Value)
	}
	fmt.Fprintf(w, ")\n\n")

	// There can be multiple equal enum values with different names.
	// So enum -> string conversion is lossy; let's report
	// the first defined name for given value.
	dupcases := make(map[uint64]string)

	// Add func String()
	fmt.Fprintf(w, "func (v %s) String() string {\n", name)
	fmt.Fprintf(w, "\tswitch v {\n")
	for _, value := range v.Values {
		name := value.Name
		if dupcases[value.Value] == "" {
			dupcases[value.Value] = name
		}
		if dupcases[value.Value] == name {
			fmt.Fprintf(w, "\tcase %s:\n", f.goifyIdentifier(name))
			fmt.Fprintf(w, "\t\treturn \"%s\"\n", f.goifyIdentifier(name))
		}
	}
	fmt.Fprintf(w, "\t}\n")
	fmt.Fprintf(w, "\treturn \"unknown\"\n")
	fmt.Fprintf(w, "}\n\n")

	// Add func CString()
	fmt.Fprintf(w, "func (v %s) CString() string {\n", name)
	fmt.Fprintf(w, "\tswitch v {\n")
	for _, value := range v.Values {
		name := value.Name
		if dupcases[value.Value] == "" {
			dupcases[value.Value] = name
		}
		if dupcases[value.Value] == name {
			fmt.Fprintf(w, "\tcase %s:\n", f.goifyIdentifier(name))
			fmt.Fprintf(w, "\t\treturn \"%s\"\n", name)
		}
	}
	fmt.Fprintf(w, "\t}\n")
	fmt.Fprintf(w, "\treturn \"unknown\"\n")
	fmt.Fprintf(w, "}\n\n")

	f.generateEnumParser(w, v, name)

	return &typeInfo{
		SystemName: v.Name,
		Name:       name,
		Kind:       "enum",
		Definition: w.String(),
	}, nil
}

func (f *GoFormatter) visitArray(v *btf.Array) (*typeInfo, error) {
	if err := f.collectChildren(v.Type); err != nil {
		return nil, err
	}
	if err := f.collectChildren(v.Index); err != nil {
		return nil, err
	}

	return &typeInfo{
		SystemName: fmt.Sprintf("[%d]%s", v.Nelems, v.Type.TypeName()),
		Name:       fmt.Sprintf("[%d]%s", v.Nelems, f.types[v.Type].Name),
	}, nil
}

func (f *GoFormatter) visitTypedef(v *btf.Typedef) (*typeInfo, error) {
	if err := f.collectChildren(v.Type); err != nil {
		return nil, err
	}

	if builtin, ok := f.builtins[v.Name]; ok {
		return &typeInfo{Name: builtin}, nil
	}

	name := f.goifyTypeName(v)

	w := &strings.Builder{}
	fmt.Fprintf(w, "type %s %s\n\n", name, f.typname(v.Type))
	f.generateTypedefParser(w, v, name)

	return &typeInfo{
		SystemName: v.Name,
		Name:       name,
		Kind:       "typedef",
		Definition: w.String(),
	}, nil
}

func (f *GoFormatter) goifyTypeName(typ btf.Type) string {
	name := typ.TypeName()

	if name == "" {
		id, err := f.spec.TypeID(typ)
		if err != nil {
			panic(fmt.Sprintf("unknown type %v: %v", typ, err))
		}
		name = fmt.Sprintf("Anonymous%d", id)
	}

	return f.goifyIdentifier(name)
}

func (f *GoFormatter) goifyIdentifier(name string) string {
	return f.prefix + snakeToPascal(name)
}

var engLower = cases.Lower(language.English)
var engTitle = cases.Title(language.English)

func capitalize(word string) string {
	return engTitle.String(engLower.String(word))
}

func snakeToPascal(name string) string {
	parts := strings.Split(name, "_")
	for i, part := range parts {
		parts[i] = capitalize(part)
	}
	return strings.Join(parts, "")
}
